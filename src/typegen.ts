import { Either, left, right } from "fp-ts/lib/Either"
import { REACT_NODE_TYPE, TranslationTypes } from "./parser"
import { format } from "prettier"
import { promises as fs } from "fs"
import { join, basename } from "path"
import { logger } from "./logger"

type TypeGenerationOptions = {
  destination: string
  interfaceName?: string
  isReact?: boolean
}

export type TypeGenerationError = {
  type: "typeGenerationError"
  message: string
}

export const generateTypings = async (
  types: TranslationTypes,
  opts: TypeGenerationOptions
): Promise<Either<TypeGenerationError, undefined>> => {
  const {
    destination,
    interfaceName = "TranslationArguments",
    isReact = true,
  } = opts
  const fileName = `${basename(destination)}.d.ts`
  const properties = Object.entries(types)
    .map(([key, values]) => {
      const out = Object.fromEntries(
        Object.entries(values).map(([key, value]) => {
          if (Array.isArray(value)) {
            const union = value.map(val => JSON.stringify(val)).join(" | ")
            return [key, union]
          } else {
            return [key, value]
          }
        })
      )
      const value =
        Object.keys(out).length === 0 ? "never" : JSON.stringify(out, null, 2)
      return `"${key}": ${value}`
    })
    .join(", \n")
  const declarations = `
    /* Generated by Kotoba, don't edit manually */
    /* eslint-disable */
    ${isReact ? `import type { ${REACT_NODE_TYPE} } from "react"` : ""}
    export type TagMapper = (input: any) => ${
      isReact ? REACT_NODE_TYPE : "string"
    }

    export interface ${interfaceName} {
      ${properties}
    }
  `

  const prettyDeclarations = format(declarations, {
    parser: "typescript",
    semi: true,
    tabWidth: 2,
  })

  try {
    await fs.mkdir(destination, { recursive: true })
    await fs.writeFile(join(destination, fileName), prettyDeclarations)
    return right(undefined)
  } catch (err) {
    if (err instanceof Error) {
      return left({
        type: "typeGenerationError",
        message: err.message,
      })
    }
    logger.error(err)
    // TODO: remove panic
    process.exit(1)
  }
}
